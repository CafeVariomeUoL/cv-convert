-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | This tool is intended to be used inside CafeVariome to convert and
--   validate various data sets that users wish to import.
--   
--   The tool takes a data file along with a <tt>.settings</tt> file
--   associated with said file. The <tt>.settings</tt> file describes how
--   data should be imported and validated.
--   
--   The tool parses JSON, TXT, CSV and XLSX files and turns each row of
--   data into a JSON object. The tool then uses a JavaScript function,
--   defined in the <tt>.settings</tt> file, to process the data row by
--   row. This function returns a JS object, which is then converted into
--   JSON and validated against a JSON schema, also provided in the
--   <tt>.settings</tt> file. If a row is valid, it is either stored in a
--   JSON output file or written directly into the CafeVariome database.
--   
--   A minimal <tt>.settings</tt> file is a JSON object with the
--   <tt>processFunction</tt> attribute:
--   
--   <pre>
--   {
--     "processFunction": "return row"
--   }
--   </pre>
--   
--   This <tt>.settings</tt> file acts as the identity on any given input.
--   The <tt>.settings</tt> file should not be created manually, but should
--   be generated by the <a>cv-convert-react</a> tool instead.
@package cv-convert
@version 0.5


-- | <i>Note: Postgres backend functions.</i>
module DB.Postgres

-- | Stores a row in the JSON <a>Value</a> format (serialising into the
--   JSONB type in Postres). If the <a>SourceID</a> and <a>SubjectID</a>
--   alredy exist, the old record is overwritten.
insertJSONBOverwriteOnConflict :: forall conn_aq8F. IConnection conn_aq8F => SourceID -> FileID -> SubjectID -> Value -> conn_aq8F -> IO ()

-- | Stores a row in the EAV triples format.
--   
--   Given the <a>Value</a>
--   
--   <pre>
--   {
--     "subject_id": "patient0",
--     "age": 25.5,
--     "address": {
--       "street": "Middle",
--       "house_no": 26,
--       "city": "Towcester"
--     }
--   }
--   </pre>
--   
--   we can generate the EAV tripples via <tt>flattenToEAV</tt>:
--   
--   <pre>
--   (
--     60bcf653-fc8e-40dd-bb15-c332a99969da,
--     [
--       (60bcf653-fc8e-40dd-bb15-c332a99969da, "subject_id", "patient0"),
--       (60bcf653-fc8e-40dd-bb15-c332a99969da, "age", "25.5"),
--       (d53f0483-1107-4a8c-b544-02e8ed54778d, "parent_uuid", "60bcf653-fc8e-40dd-bb15-c332a99969da"),
--       (d53f0483-1107-4a8c-b544-02e8ed54778d, "parent_attr", "address"),
--       (d53f0483-1107-4a8c-b544-02e8ed54778d, "city", "Towcester"),
--       (d53f0483-1107-4a8c-b544-02e8ed54778d, "street", "Middle"),
--       (d53f0483-1107-4a8c-b544-02e8ed54778d, "house_no", "26")
--     ]
--   )
--   </pre>
--   
--   These are then inserted into the <tt>eavs</tt> table:
--   
--   TODO: table
insertEAV :: IConnection conn => UUID -> SourceID -> FileID -> SubjectID -> Text -> Text -> conn -> IO ()

-- | The <tt>eavs_jsonb_attributes_values</tt> table stores all the
--   possible values, generated by <tt>createAllPathsWithValues</tt> for
--   all the inserted objects. For example, given these two rows of data:
--   
--   <pre>
--   [
--     {"gender": "female", "age": 27},
--     {"gender": "male", "age": 25}
--   ]
--   </pre>
--   
--   We generate and insert the following records into
--   <tt>eavs_jsonb_attributes_values</tt>:
--   
--   TODO: table
--   
--   If we add a third record <tt>r</tt>
--   
--   <pre>
--   {"gender": "unknown", "age": 35},
--   </pre>
--   
--   and insert the result <tt>createAllPathsWithValues</tt> <tt>r</tt>
--   into <tt>eavs_jsonb_attributes_values</tt>, the <tt>values</tt> of
--   both rows will get merged with the values already in the table:
--   
--   TODO: table
insertJSONBAttributesValuesMergeOnConflict :: forall conn_aq91. IConnection conn_aq91 => SourceID -> Value -> Value -> conn_aq91 -> IO ()

-- | This function removes duplicates in the <tt>values</tt> column of the
--   <tt>eavs_jsonb_attributes_values</tt> table.
--   
--   Should be run after we have inserted all the records via
--   <a>insertJSONBAttributesValuesMergeOnConflict</a>.
cleanupJSONBAttributesValues :: forall conn_aq9c. IConnection conn_aq9c => conn_aq9c -> IO (Maybe Int)
insertError :: forall conn_aq9o. IConnection conn_aq9o => SourceID -> FileID -> String -> conn_aq9o -> IO ()
clearErrors :: forall conn_aq9s. IConnection conn_aq9s => SourceID -> FileID -> conn_aq9s -> IO ()
getFileID :: forall conn_aq9w. IConnection conn_aq9w => SourceID -> String -> conn_aq9w -> IO (Maybe FileID)
deleteSourceFromEAVSJSONB :: forall conn_aq9A. IConnection conn_aq9A => SourceID -> conn_aq9A -> IO ()
deleteSourceFromEAVSJSONBAttributesValues :: forall conn_aq9E. IConnection conn_aq9E => SourceID -> conn_aq9E -> IO ()
instance Data.Convertible.Base.Convertible Data.Aeson.Types.Internal.Value Database.HDBC.SqlValue.SqlValue
instance Data.Convertible.Base.Convertible Database.HDBC.SqlValue.SqlValue Data.Aeson.Types.Internal.Value
instance Data.Convertible.Base.Convertible Data.UUID.Types.Internal.UUID Database.HDBC.SqlValue.SqlValue
instance Data.Convertible.Base.Convertible DB.Types.SourceID Database.HDBC.SqlValue.SqlValue
instance Data.Convertible.Base.Convertible DB.Types.SubjectID Database.HDBC.SqlValue.SqlValue
instance Data.Convertible.Base.Convertible DB.Types.FileID Database.HDBC.SqlValue.SqlValue
instance Data.Convertible.Base.Convertible Database.HDBC.SqlValue.SqlValue DB.Types.FileID

module DB.MySQL
insertEAV :: UUID -> SourceID -> FileID -> SubjectID -> Text -> Text -> MySQLConn -> IO ()
insertEAVPrepareQuery :: UUID -> SourceID -> FileID -> SubjectID -> Text -> Text -> Query
insertError :: SourceID -> FileID -> String -> MySQLConn -> IO ()
clearErrors :: SourceID -> FileID -> MySQLConn -> IO ()
getFileID :: SourceID -> String -> MySQLConn -> IO (Maybe FileID)

module DB
data DBType :: Type -> Type
[Postgres] :: DBType Connection
[MySQL] :: DBType MySQLConn
data SomeDBType
SomeDBType :: DBType con_ty -> SomeDBType
newtype SourceID
SourceID :: Int -> SourceID
[unSourceID] :: SourceID -> Int
newtype SubjectID
SubjectID :: String -> SubjectID
[unSubjectID] :: SubjectID -> String
newtype FileID
FileID :: Int -> FileID
newtype User
User :: String -> User
newtype Password
Password :: String -> Password
newtype Host
Host :: String -> Host
newtype Port
Port :: Maybe String -> Port
newtype Database
Database :: String -> Database
type ConnInfo = (SomeDBType, User, Password, Host, Port, Database)
class DBConn con_ty
connect :: DBConn con_ty => User -> Password -> Host -> Port -> Database -> IO con_ty
disconnect :: DBConn con_ty => con_ty -> IO ()
dbType :: DBConn con_ty => DBType con_ty
getFileID :: forall con. DBConn con => SourceID -> String -> con -> IO (Maybe FileID)
insertEAV :: forall con. DBConn con => UUID -> SourceID -> FileID -> SubjectID -> Text -> Text -> con -> IO ()
insertError :: forall con. DBConn con => SourceID -> FileID -> String -> con -> IO ()
clearErrors :: forall con. DBConn con => SourceID -> FileID -> con -> IO ()
mkConnInfo :: String -> Maybe ConnInfo
instance DB.DBConn Database.HDBC.PostgreSQL.Pure.Connection
instance DB.DBConn Database.MySQL.Connection.MySQLConn

module Runtime.Types

-- | Type encoding the input document type along with potential
--   parsing/processing options.
data FileType
TXTFile :: Int -> FileType
[startFromLine] :: FileType -> Int
JSONFile :: FileType
CSVFile :: FileType
XLSXFile :: Maybe SheetName -> FileType
[sheetName] :: FileType -> Maybe SheetName
data Specified a
Specified :: a -> Specified a
Inferred :: a -> Specified a
Unspecified :: Specified a

-- | Parses a file extension, such as <tt>.txt</tt> into <a>TXTFile</a>.
--   Returns <a>Nothing</a> if the extension does not mach any of the
--   <a>FileType</a>s.
parseFileType :: Maybe Int -> Maybe SheetName -> Maybe Text -> Parser (Specified FileType)
fromSpecifiedFileType :: String -> Specified FileType -> FileType

-- | Data type used to describe the error reporting/handling behaviour when
--   processing a row. Other than 'Terminate, all other options result in
--   the error from a row being recorded/printed, with the computation
--   continuing onto the next row.
data ErrorOpt
Terminate :: ErrorOpt
LogToConsole :: ErrorOpt
LogToFile :: ErrorOpt
Log :: ErrorOpt
newtype SheetName
SheetName :: Text -> SheetName
[unSheetName] :: SheetName -> Text
data LibFunctions
Inline :: ByteString -> LibFunctions
External :: Text -> ByteString -> LibFunctions
[url] :: LibFunctions -> Text
[hash] :: LibFunctions -> ByteString

-- | Internal representation of a '.settings' file.
data Settings
Settings :: Text -> Maybe LibFunctions -> Maybe Schema -> Specified FileType -> Maybe ErrorOpt -> Settings

-- | A string containg the JS function which will be applied to the input
[processFunction] :: Settings -> Text
[libraryFunctions] :: Settings -> Maybe LibFunctions

-- | A JSON schema used for output validation
[jsonSchema] :: Settings -> Maybe Schema

-- | This parameter can be used to specify the parsing behaviour for files
--   such as <tt>.phenotype</tt>, which should be parsed as <tt>JSON</tt>.
--   If left blank, parsing defaults to either file extension (if it
--   corresponds to one of the <a>FileType</a>s), otherwise <a>TXTFile</a>.
--   , startFrom :: Maybe Int -- ^ This parameter specifies how many rows
--   should be skipped. Only works when parsing TXTFile files
[openAs] :: Settings -> Specified FileType

-- | Specifies the error logging behaviour , worksheet :: Maybe SheetName
--   -- ^ Used to specify which worksheet should be parsed. Only works for
--   <a>XLSXFile</a> files. If left blank, defaults to first found
--   worksheet.
[onError] :: Settings -> Maybe ErrorOpt

-- | Defines the output behaviour, either writing to a JSON/SQL file or a
--   database.
data DataOutputOpt
JSONFileOutputOpt :: DataOutputOpt

-- | If writing to a database, the <a>ConnInfo</a> and <a>SourceID</a>
--   paramameters must be supplied
DBOutputOpt :: ConnInfo -> SourceID -> DataOutputOpt

-- | If writing to an SQL file, the <a>SourceID</a> paramameter must be
--   supplied
SQLFileOutputOpt :: SourceID -> DataOutputOpt

-- | Sum type for the handles for different output options.
data DataOutput

-- | <a>Handle</a> points to an open JSON file
JSONFileOutput :: Handle -> DataOutput
DBOutput :: con_t -> SourceID -> FileID -> DataOutput

-- | Database connection handle, depends on the backend (MySQL/Postgres).
[con] :: DataOutput -> con_t
[sourceID] :: DataOutput -> SourceID
[fileID] :: DataOutput -> FileID

-- | <a>Handle</a> points to an open SQL file
SQLFileOutput :: SourceID -> Handle -> DataOutput
newtype ErrorHandling
ErrorHandling :: (ErrorOpt, Maybe DataOutput) -> ErrorHandling
instance GHC.Generics.Generic Runtime.Types.Settings
instance GHC.Classes.Eq Runtime.Types.Settings
instance GHC.Show.Show Runtime.Types.Settings
instance GHC.Generics.Generic Runtime.Types.LibFunctions
instance GHC.Classes.Eq Runtime.Types.LibFunctions
instance GHC.Show.Show Runtime.Types.LibFunctions
instance GHC.Generics.Generic Runtime.Types.FileType
instance GHC.Classes.Eq Runtime.Types.FileType
instance Data.Aeson.Types.FromJSON.FromJSON Runtime.Types.SheetName
instance GHC.Generics.Generic Runtime.Types.SheetName
instance GHC.Classes.Eq Runtime.Types.SheetName
instance GHC.Show.Show Runtime.Types.SheetName
instance GHC.Generics.Generic Runtime.Types.ErrorOpt
instance GHC.Classes.Eq Runtime.Types.ErrorOpt
instance GHC.Show.Show Runtime.Types.ErrorOpt
instance GHC.Classes.Eq a => GHC.Classes.Eq (Runtime.Types.Specified a)
instance GHC.Show.Show a => GHC.Show.Show (Runtime.Types.Specified a)
instance Data.Aeson.Types.FromJSON.FromJSON Runtime.Types.Settings
instance Data.Aeson.Types.FromJSON.FromJSON Runtime.Types.LibFunctions
instance GHC.Show.Show Runtime.Types.FileType
instance Data.Aeson.Types.FromJSON.FromJSON Runtime.Types.ErrorOpt

module Runtime.Error
handleError :: (MonadThrow m, MonadIO m) => ErrorHandling -> Int -> SomeRuntimeException -> Value -> Value -> m ()
data SomeRuntimeException
SomeRuntimeException :: e -> SomeRuntimeException
runtimeExceptionToException :: (Exception e, ToJSON e) => e -> SomeException
runtimeExceptionFromException :: Exception e => SomeException -> Maybe e
newtype RuntimeException e
RuntimeException :: e -> RuntimeException e
data SubjectIDNotFound
SubjectIDNotFound :: SubjectIDNotFound
data SheetNotFound
SheetNotFound :: Text -> SheetNotFound
[name] :: SheetNotFound -> Text
data CSVParseError
CSVParseError :: String -> CSVParseError
[message] :: CSVParseError -> String
data FileIDNotFound
FileIDNotFound :: String -> FileIDNotFound
[file] :: FileIDNotFound -> String
data RowError
RowError :: Int -> e -> Value -> Value -> RowError
[row] :: RowError -> Int
[_error] :: RowError -> e
[input] :: RowError -> Value
[output] :: RowError -> Value
data HashMismatch
HashMismatch :: Text -> Text -> Text -> HashMismatch
[url] :: HashMismatch -> Text
[expected_hash] :: HashMismatch -> Text
[found_hash] :: HashMismatch -> Text
data RuntimeError
RuntimeError :: String -> RuntimeError
instance GHC.Exception.Type.Exception Runtime.Error.RuntimeError
instance Data.Aeson.Types.ToJSON.ToJSON Runtime.Error.RuntimeError
instance GHC.Generics.Generic Runtime.Error.RuntimeError
instance GHC.Exception.Type.Exception Runtime.Error.HashMismatch
instance Data.Aeson.Types.ToJSON.ToJSON Runtime.Error.HashMismatch
instance GHC.Generics.Generic Runtime.Error.HashMismatch
instance GHC.Exception.Type.Exception Runtime.Error.FileIDNotFound
instance Data.Aeson.Types.ToJSON.ToJSON Runtime.Error.FileIDNotFound
instance GHC.Generics.Generic Runtime.Error.FileIDNotFound
instance GHC.Exception.Type.Exception Runtime.Error.CSVParseError
instance Data.Aeson.Types.ToJSON.ToJSON Runtime.Error.CSVParseError
instance GHC.Generics.Generic Runtime.Error.CSVParseError
instance GHC.Exception.Type.Exception Runtime.Error.SheetNotFound
instance Data.Aeson.Types.ToJSON.ToJSON Runtime.Error.SheetNotFound
instance GHC.Generics.Generic Runtime.Error.SheetNotFound
instance GHC.Exception.Type.Exception Runtime.Error.SubjectIDNotFound
instance Data.Aeson.Types.ToJSON.ToJSON Runtime.Error.SubjectIDNotFound
instance GHC.Generics.Generic Runtime.Error.SubjectIDNotFound
instance GHC.Show.Show e => GHC.Show.Show (Runtime.Error.RuntimeException e)
instance GHC.Generics.Generic (Runtime.Error.RuntimeException e)
instance GHC.Show.Show Runtime.Error.RuntimeError
instance GHC.Show.Show Runtime.Error.HashMismatch
instance GHC.Show.Show Runtime.Error.RowError
instance Data.Aeson.Types.ToJSON.ToJSON Runtime.Error.RowError
instance GHC.Exception.Type.Exception Runtime.Error.RowError
instance GHC.Show.Show Runtime.Error.FileIDNotFound
instance GHC.Show.Show Runtime.Error.CSVParseError
instance GHC.Show.Show Runtime.Error.SheetNotFound
instance GHC.Show.Show Runtime.Error.SubjectIDNotFound
instance (GHC.Generics.Generic a, Data.Aeson.Types.Class.GToJSON Data.Aeson.Types.Generic.Zero (GHC.Generics.Rep a)) => Data.Aeson.Types.ToJSON.ToJSON (Runtime.Error.RuntimeException a)
instance (GHC.Show.Show e, Data.Typeable.Internal.Typeable e, GHC.Generics.Generic e, Data.Aeson.Types.Class.GToJSON Data.Aeson.Types.Generic.Zero (GHC.Generics.Rep e)) => GHC.Exception.Type.Exception (Runtime.Error.RuntimeException e)
instance GHC.Show.Show Runtime.Error.SomeRuntimeException
instance Data.Aeson.Types.ToJSON.ToJSON Runtime.Error.SomeRuntimeException
instance GHC.Exception.Type.Exception Runtime.Error.SomeRuntimeException


module JSON.Utils
getSubjectID :: MonadThrow m => Value -> m SubjectID

-- | This function takes a JSON object and generates all paths to the leaf
--   nodes, collecting all the leaf values in a set. E.g. given:
--   
--   <pre>
--   {
--     "name": "Sam",
--     "age": 25.5,
--     "address": {
--       "street": "Middle",
--       "house_no": 26,
--       "city": "Towcester"
--     }
--   }
--   </pre>
--   
--   <a>createAllPathsWithValues</a> produces the following map:
--   
--   <pre>
--   {"name": "str"} -&gt; {"Sam"},
--   {"age": "float"} -&gt; {25.5},
--   {"address": {"street": "str"}} -&gt; {"Middle"},
--   {"address": {"house_no": "int"}} -&gt; {26},
--   {"address": {"city": "str"}} -&gt; {"Towcester"}
--   </pre>
--   
--   We return a set of value, in case we encounter the same path at in
--   different objects within the same array:
--   
--   <pre>
--   [
--     {"name": "Alice", "age": 27}
--     {"name": "John", "age": 25},
--   ]
--   </pre>
--   
--   Here, <a>createAllPathsWithValues</a> outputs:
--   
--   <pre>
--   [{"name": "str"}] -&gt; {"Alice", "John"},
--   [{"age": "int"}] -&gt; {27, 25},
--   </pre>
createAllPathsWithValues :: Value -> HashMap Value (HashSet Value)

-- | This function takes a JSON object and flattens it into a list of EAV
--   triples. The entities are given a uniquely generated UUID, to prevent
--   any clashes with data already in the EAV database. As a result,
--   running this function repeatedly will generate different output, since
--   the UUIDs are generated at random.
--   
--   For example, given:
--   
--   <pre>
--   {
--     "name": "Sam",
--     "age": 25.5,
--     "address": {
--       "street": "Middle",
--       "house_no": 26,
--       "city": "Towcester"
--     }
--   }
--   </pre>
--   
--   <a>flattenToEAV</a> returns the UUID of the root object and a list of
--   triples, encoding the original object:
--   
--   <pre>
--   (
--     60bcf653-fc8e-40dd-bb15-c332a99969da,
--     [
--       (60bcf653-fc8e-40dd-bb15-c332a99969da, "name", "Sam"),
--       (60bcf653-fc8e-40dd-bb15-c332a99969da, "age", "25.5"),
--       (d53f0483-1107-4a8c-b544-02e8ed54778d, "parent_uuid", "60bcf653-fc8e-40dd-bb15-c332a99969da"),
--       (d53f0483-1107-4a8c-b544-02e8ed54778d, "parent_attr", "address"),
--       (d53f0483-1107-4a8c-b544-02e8ed54778d, "city", "Towcester"),
--       (d53f0483-1107-4a8c-b544-02e8ed54778d, "street", "Middle"),
--       (d53f0483-1107-4a8c-b544-02e8ed54778d, "house_no", "26")
--     ]
--   )
--   </pre>
--   
--   Nesting information is preserved by including the <tt>parent_uuid</tt>
--   and <tt>parent_attr</tt> triples:
--   
--   <pre>
--   (&lt;child object UUID&gt;, "parent_uuid", &lt;parent UUID&gt;),
--   (&lt;child object UUID&gt;, "parent_attr", &lt;attribute name&gt;)
--   </pre>
flattenToEAV :: MonadIO m => Value -> m (UUID, [(UUID, Text, Text)])


-- | The runtime module exports the main functionality of the cv-convert
--   tool.
module Runtime

-- | The <a>loadLibrary</a> function takse a <a>LibFunctions</a> parameter,
--   which either contains an inline JS script or points to an external
--   script via URL. The library functions must be stored in a specific
--   way, namely the library file must be of the form
--   
--   <pre>
--   Lib.fun1 = (a,b) =&gt; {...},
--   Lib.fun2 = ...
--   </pre>
loadLibrary :: (MonadThrow m, MonadIO m, MonadReader JSContextPtr m) => LibFunctions -> m ()

-- | This function runs the converter function on the row and header input
--   data, then runs the validator(to check that the JSON <a>Value</a> that
--   was produced validates agains the JSON schema).
--   
--   If the output is valid, the data is either stored in a database or a
--   JSON text file. When inserting into database, the output is stored in
--   two different tables:
--   
--   <ul>
--   <li>The <tt>insertJSONBOverwriteOnConflict</tt> function stores the
--   data as Postgres JSONB in the <tt>eavs_jsonb_attributes_values</tt>
--   table</li>
--   <li><a>flattenToEAV</a> is used to generate flattened EAV triples form
--   the given JOSn object, which are then stored in the <tt>eavs</tt>
--   table via <a>insertEAV</a></li>
--   </ul>
--   
--   Finally, we return result of running <a>createAllPathsWithValues</a>
--   on the JSON output data.
convertRow :: (MonadMask m, MonadIO m) => Int -> row -> header -> (row -> header -> m Value) -> (Value -> [ValidatorFailure]) -> DataOutput -> ErrorHandling -> Value -> m (HashMap Value (HashSet Value))

-- | Helper function which loops over the rows of the given input,
--   collecting and merging all the resulting maps (generated inside
--   <a>convertRow</a> via <a>createAllPathsWithValues</a>)
processRow :: (FoldableWithIndex Int f, MonadThrow m) => f row -> (Int -> row -> m (HashMap Value (HashSet Value))) -> m (HashMap Value (HashSet Value))
processTxtFile :: (MonadMask m, MonadIO m, MonadReader JSContextPtr m) => (JSValue -> JSValue -> m Value) -> (Value -> [ValidatorFailure]) -> FilePath -> DataOutput -> ErrorHandling -> Int -> m (HashMap Value (HashSet Value))
processXlsxFile :: (MonadMask m, MonadIO m, MonadReader JSContextPtr m) => (JSValue -> JSValue -> m Value) -> (Value -> [ValidatorFailure]) -> FilePath -> DataOutput -> ErrorHandling -> Maybe SheetName -> m (HashMap Value (HashSet Value))
processCsvFile :: (MonadMask m, MonadIO m, MonadReader JSContextPtr m) => (JSValue -> JSValue -> m Value) -> (Value -> [ValidatorFailure]) -> FilePath -> DataOutput -> ErrorHandling -> m (HashMap Value (HashSet Value))
processJsonFile :: (MonadMask m, MonadIO m, MonadReader JSContextPtr m) => (JSValue -> JSValue -> m Value) -> (Value -> [ValidatorFailure]) -> FilePath -> DataOutput -> ErrorHandling -> m (HashMap Value (HashSet Value))
processFile :: (MonadMask m, MonadIO m, MonadReader JSContextPtr m) => (JSValue -> JSValue -> m Value) -> (Value -> [ValidatorFailure]) -> FilePath -> FileType -> DataOutputOpt -> ErrorOpt -> m ()
